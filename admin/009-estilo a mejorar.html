<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Admin Dashboard – FloMViDex</title>
  <style>
/* ===========================RESET BÁSICO=========================== */body{font-family:Arial,sans-serif;margin:20px;background:#fafafa;color:#222}h1,h2,h3{margin:0;color:#0f8b8d;font-weight:600}header{position:sticky;top:0;z-index:100;background:white;padding:10px 0;display:flex;flex-wrap:wrap;justify-content:space-between;gap:20px;margin-bottom:15px;border-bottom:2px solid #e5e5e5}/* ===========================TABS (No IA,más web real)=========================== */.tabs{display:flex;gap:6px;margin-top:10px}.tab{padding:8px 14px;background:#fff;border:1px solid #0f8b8d33;border-radius:6px;cursor:pointer;color:#0f8b8d;font-size:14px;transition:background 0.2s ease,border-color 0.2s ease}.tab:hover{border-color:#0f8b8d77;background:#f0fafa}.tab.active{background:#0f8b8d;color:white;border-color:#0f8b8d;font-weight:bold}/* ===========================FILTROS + SEARCH=========================== */.filters{margin-top:10px;display:flex;flex-wrap:wrap;gap:10px}.filters input,.filters select{padding:6px 10px;border-radius:6px;border:1px solid #0f8b8d55;font-size:14px;background:white;color:#0f8b8d}#table-toolbar{display:flex;gap:10px}#delete-selected-btn,#export-json-btn{padding:6px 10px;border-radius:6px;background:#0f8b8d;color:white;border:none;cursor:pointer;font-size:13px}#delete-selected-btn:hover,#export-json-btn:hover{background:#0c6e70}/* ===========================FORM CREATE=========================== */form{display:flex;flex-direction:column;gap:10px}form input[type=text],form input[type=file]{padding:8px 10px;border-radius:6px;border:1px solid #ccc;background:white}form button{padding:8px 12px;font-size:14px;cursor:pointer;border-radius:6px;background:#ff8eb7;color:white;border:none}form button:hover{background:#ff77a8}/* ===========================TABLA=========================== */table{width:100%;border-collapse:collapse;margin-top:15px;background:white;border-radius:8px;overflow:hidden;border:1px solid #e5e5e5}th{background:#eaf8f7;color:#0f8b8d;padding:10px;font-weight:bold;font-size:14px}td{padding:10px;border-top:1px solid #eee;font-size:14px}tr:hover{background:#fafafa}.no-data{text-align:center;font-style:italic;color:#888}/* ===========================ACCIONES=========================== */.actions button{margin-right:4px;padding:5px 9px;font-size:12px;border-radius:5px;cursor:pointer;border:none;color:white;background:#0f8b8d}.actions button:hover{background:#0c6e70}/* ===========================PLAYER=========================== */#player-info{font-size:13px;margin-bottom:8px;color:#0f8b8d}#header-player{width:100%;border:2px solid #ff8eb7;border-radius:8px;padding:2px}
  </style>
</head>
<body>
  <div class="page">
    <header>
      <!-- Texto + directorios + buscador con filtros -->
      <div class="divider" style="flex: 2 1 320px;">
        <h1>Admin Dashboard para FloMViDex</h1>
        <div id="current-directory-label">
          <h3>Directorio actual:</h3>
        </div>
        <span id="directory-stats"></span>          
        
        <div class="filters">
          <input type="text" id="search-input" placeholder="Buscar por título, archivo, artista o tag...">
          <select id="extension-filter">
            <option value="all">Todas las extensiones</option>
            <option value="opus">Solo .opus</option>            
            <option value="mp3">Solo .mp3</option>
          </select>
          <div id="table-toolbar">
            <button id="delete-selected-btn">Eliminar seleccionados</button>
            <button id="export-json-btn">Exportar JSON del directorio</button>
          </div>          
        </div>
      </div>

      <div class="tabs">
        <div class="tab active" data-dir="mc1">maidcore 1.0</div>
        <div class="tab" data-dir="mc2">maidcore 2.0</div>
        <div class="tab" data-dir="mc3">maidcore 3.0</div>
        <div class="tab" data-dir="mc4">maidcore 4.0</div>
      </div>

      <!-- Reproductor -->
      <div class="divider" style="flex: 1 1 260px;">
        <h2>Reproductor básico</h2>
        <div id="player-info"></div>
        <audio id="header-player" controls>
          Tu navegador no soporta el elemento de audio.
        </audio>
      </div>

      <!-- CREATE -->
      <div class="divider" style="flex: 1 1 260px;">
        <h2>Crear nuevo track</h2>
        <form id="create-form">
          <input type="text" name="title" placeholder="[OPCIONAL] Título base del track">
          <input type="text" name="artist" placeholder="[OPCIONAL] Artista">
          <input type="text" name="tags" placeholder="[OPCIONAL] Tags (coma, separadas)">
          <input type="file" name="file" accept="audio/*" multiple required>
          <button type="submit">Subir</button>
        </form>
      </div>     
    </header>

    <table id="tracks-table">
      <thead>
        <tr>
          <th class="select-col"><input type="checkbox" id="select-all"></th>
          <th>ID</th>
          <th>Título</th>
          <th>Artista</th>
          <th>Tags</th>
          <th>Archivo</th>
          <th>Acciones</th>
        </tr>
      </thead> 
      <tbody></tbody>
    </table>
  </div>

  <script>
    //Mapa en memoria para guardar Blob URLs por track (no se guarda en localStorage)
    // clave: `${directorio}_${id}`
    const fileBlobs = {};

    // Variables principales    
    let tracksByDirectory = {};
    let nextIdByDirectory = {};
    const emptyTracks = () => ({mc1:[],mc2:[],mc3:[],mc4:[]});
      
    // Clave de localStorage  
    const LS_KEY = 'flomvidex_tracks_v1';
    const saveLS = () => {
      try { localStorage.setItem(LS_KEY, JSON.stringify(tracksByDirectory)); }
      catch(e){ console.error(e); }
    };
    const loadLS = () => {
      try { 
        const raw = localStorage.getItem(LS_KEY);
        tracksByDirectory = raw ? JSON.parse(raw) : emptyTracks();
        const base = emptyTracks();
        Object.keys(base).forEach(d => { if (!tracksByDirectory[d]) tracksByDirectory[d]=[]; });
      } catch(e) {
        tracksByDirectory = emptyTracks();
      }
      saveLS();
    };
    // Inicializar datos dinámicos
    loadLS();

    // Devuelve el primer ID libre (1,2,3,...) en el directorio dado
    const getNextFreeId = dir => {
      const arr = tracksByDirectory[dir] || [];
      if (!arr.length) return 1;
      // Obtener todos los IDs usados
      const used = new Set(arr.map(t => t.id));
      // Buscar el primer entero positivo que no esté usado
      let id = 1;
      while (used.has(id)) {
        id++;
      }
      return id;
    };


    ////////////////////////////////////
    // Selector de cambios entre tablas
    ////////////////////////////////////
    let currentDirectory = 'mc1';
    // Asociamos el mapa web de nombres lógicos con las carpeta físicas en nuestro directorio
    const DIR_PATHS = {
      mc1: 'maidcore 1.0',
      mc2: 'maidcore 2.0',
      mc3: 'maidcore 3.0',
      mc4: 'maidcore 4.0'
    };

    // Elementos del DOM    
    const tabs = document.querySelectorAll('.tab');
    const tableBody = document.querySelector('#tracks-table tbody');
    const dirLabel = document.getElementById('current-directory-label');
    const createForm = document.getElementById('create-form');
    const searchInput = document.getElementById('search-input');
    const extensionFilter = document.getElementById('extension-filter');
    const headerPlayer = document.getElementById('header-player');
    const playerInfo = document.getElementById('player-info');
    // Toolbar del header    
    const deleteSelectedBtn = document.getElementById('delete-selected-btn');
    const exportJsonBtn = document.getElementById('export-json-btn');
    const selectAllCheckbox = document.getElementById('select-all');

    function updateDirectoryLabel() {
      const allTracks = tracksByDirectory[currentDirectory] || [];          
      const totalTracks = allTracks.length;    
      dirLabel.innerHTML = '<h3>Directorio actual:</h3> ' + currentDirectory + ' Tracks: ' + totalTracks;
    }

// Reproducir track en el reproductor del header
    const playInHeader = track => {
      const key = `${currentDirectory}_${track.id}`;
      const blobUrl = fileBlobs[key];
      if (blobUrl) {
        headerPlayer.src = blobUrl;         // Reproducir desde Blob (subido en esta sesión)
      } else {
        const folderName = DIR_PATHS[currentDirectory] || currentDirectory;
        headerPlayer.src = `../media/mp3/real mp3/${folderName}/${track.file}`;        
        // Cambiar el valor de track.file como ruta directa. Por ejemplo, si tus audios están en /audio/mc1/, podrías usarse: headerPlayer.src = `audio/${currentDirectory}/${track.file}`;
      }

      headerPlayer.play().catch(()=>{});
      if (playerInfo) {
        playerInfo.textContent =
          (track.title || 'Sin título') + ' – ' +
          (track.artist || '') + ' (' + track.file + ')';
      }
    };
            
// Eliminar track por ID dentro del directorio actual
    const deleteTrack = id => {
      const arr = tracksByDirectory[currentDirectory];
      const i = arr.findIndex(t => t.id===id);
      if (i>-1) {
        // Liberar blob si existe
        const key = `${currentDirectory}_${id}`;
        if (fileBlobs[key]) {
          URL.revokeObjectURL(fileBlobs[key]);
          delete fileBlobs[key];
        }
        arr.splice(i,1);
        saveLS();
        loadTracks();
      }
    };

// Cargar tracks en la tabla según directorio + filtros
    const loadTracks = () => {
      // Ordenar por ID antes de mostrar
      tracksByDirectory[currentDirectory].sort((a, b) => a.id - b.id);         
      tableBody.innerHTML = '';
      const all = tracksByDirectory[currentDirectory] || [];
      const term = searchInput.value.trim().toLowerCase();
      const ext = extensionFilter.value;

      const filtered = all.filter(t => {
        const title = (t.title||'').toLowerCase();
        const file = (t.file||'').toLowerCase();
        const artist = (t.artist||'').toLowerCase();
        const tagsText = Array.isArray(t.tags) ? t.tags.join(' ').toLowerCase() : (t.tags||'').toLowerCase();
        const textMatch = !term || title.includes(term) || file.includes(term) || artist.includes(term) || tagsText.includes(term);
        const extMatch = ext==='all' ? true : file.split('.').pop()===ext;
        return textMatch && extMatch;
      });

// Cabecera de casilla en blanco, importante para "eliminar seleccionados"
      if (selectAllCheckbox) selectAllCheckbox.checked = false;

      if (!filtered.length) {
        const row = document.createElement('tr');
        const cell = document.createElement('td');
        cell.colSpan = 7;
        cell.textContent = 'No hay tracks en este directorio con el filtro actual.';
        cell.className = 'no-data';
        row.appendChild(cell);
        tableBody.appendChild(row);
        updateDirectoryLabel();
        return;
      }

      filtered.forEach(track => {
        const row = document.createElement('tr');

// Selección
        const selectCell = document.createElement('td');
        selectCell.className = 'select-col';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.className = 'row-select';
        cb.dataset.id = track.id;
        selectCell.appendChild(cb);
// ID
        const idCell = document.createElement('td');
        idCell.textContent = track.id;
// Título (edición rápida)
        const titleCell = document.createElement('td');
        titleCell.textContent = track.title;
        titleCell.addEventListener('dblclick', () => {
          const input = document.createElement('input');
          input.type = 'text';
          input.value = track.title;
          input.className = 'title-edit-input';
          titleCell.textContent = '';
          titleCell.appendChild(input);
          input.focus();
          const save = () => {
            const val = input.value.trim();
            if (val) {
              track.title = val;
              saveLS();
            }
            loadTracks();
          };
          input.addEventListener('blur', save);
          input.addEventListener('keydown', e => {
            if (e.key==='Enter') input.blur();
            if (e.key==='Escape') loadTracks();
          });
        });

// Artista
        const artistCell = document.createElement('td');
        artistCell.textContent = track.artist || '-';
// Tags
        const tagsCell = document.createElement('td');
        tagsCell.textContent = Array.isArray(track.tags) ? track.tags.join(', ') : (track.tags||'-');
// Archivo 
        const fileCell = document.createElement('td');
        fileCell.textContent = track.file;
// Acciones
        const actionsCell = document.createElement('td');
        actionsCell.className = 'actions';
        const playBtn = document.createElement('button');
        playBtn.textContent = 'Reproducir';
        playBtn.addEventListener('click', () => playInHeader(track));
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Eliminar';
        deleteBtn.addEventListener('click', () => deleteTrack(track.id));

// Adiccion de las cabeceras
// Acciones dentro de la tabla grande        
        actionsCell.appendChild(playBtn);
        actionsCell.appendChild(deleteBtn);

 // Resto de Cabeceras de la tabla grande
        row.appendChild(selectCell);
        row.appendChild(idCell);
        row.appendChild(titleCell);
        row.appendChild(artistCell);
        row.appendChild(tagsCell);
        row.appendChild(fileCell);
        row.appendChild(actionsCell);
        tableBody.appendChild(row);
      });

      updateDirectoryLabel();
    };

// Cambiar de pestaña (directorio)
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        tabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        currentDirectory = tab.dataset.dir;
        if (!tracksByDirectory[currentDirectory]) {
          tracksByDirectory[currentDirectory] = [];
          nextIdByDirectory[currentDirectory] = 1;
          saveLS();
        }
        updateDirectoryLabel();
        loadTracks();
      });
    });

// Crear nuevos tracks (múltiples archivos)
    createForm.addEventListener('submit', e => {
      e.preventDefault();
      const fd = new FormData(createForm);
      const titleBase = (fd.get('title')||'').trim();
      const artistBase = (fd.get('artist')||'').trim();
      const tagsRaw = (fd.get('tags')||'').trim();
      const files = fd.getAll('file');
      if (!files || !files.length) return;
      if (!tracksByDirectory[currentDirectory]) {
        tracksByDirectory[currentDirectory] = [];
        nextIdByDirectory[currentDirectory] = 1;
      }
      const tagsArray = tagsRaw ? tagsRaw.split(',').map(t=>t.trim()).filter(Boolean) : [];

      files.forEach((file,i) => {
        if (!file || !file.name) return;

        const title = titleBase
          ? (files.length>1 ? `${titleBase} (${i+1})` : titleBase) : file.name;

        // Calculamos ID antes de crear el track
        const id = getNextFreeId(currentDirectory);

        const track = {
          id,
          title,
          file: file.name,           // nombre del archivo
          artist: artistBase || '',
          tags: tagsArray
        };

        // Crear Blob URL para este archivo (solo en la sesión actual)
        const blobUrl = URL.createObjectURL(file);
        const key = `${currentDirectory}_${id}`;
        fileBlobs[key] = blobUrl;

        tracksByDirectory[currentDirectory].push(track);
      });

      saveLS();
      createForm.reset();
      loadTracks();
    });                    // Fin del formulario para el CREATE
    
    
// Botón "Eliminar seleccionados"
    if (deleteSelectedBtn) {
      deleteSelectedBtn.addEventListener('click', () => {
        const checked = document.querySelectorAll('.row-select:checked');
        if (!checked.length) {
          alert('Selecciona al menos un track para eliminar');
          return;
        }
        if (confirm(`¿Eliminar ${checked.length} track(s)?`)) {
          const ids = Array.from(checked).map(cb => parseInt(cb.dataset.id,10));
          ids.forEach(id => {
            const trackKey = `${currentDirectory}_${id}`;
            if (fileBlobs[trackKey]) {
              URL.revokeObjectURL(fileBlobs[trackKey]);
              delete fileBlobs[trackKey];
            }
          });
          tracksByDirectory[currentDirectory] =
            (tracksByDirectory[currentDirectory]||[]).filter(t => !ids.includes(t.id));
          saveLS();
          loadTracks();
        }
      });
    }

// Botón "Exportar JSON del directorio"
    if (exportJsonBtn) {
      exportJsonBtn.addEventListener('click', () => {
        const data = tracksByDirectory[currentDirectory] || [];
        console.log('JSON exportado para', currentDirectory, JSON.stringify(data,null,2));
        alert('JSON del directorio exportado a la consola (F12).');
      });
    }

// Checkbox "seleccionar todo"
    if (selectAllCheckbox) {
      selectAllCheckbox.addEventListener('change', () => {
        document.querySelectorAll('.row-select').forEach(cb => cb.checked = selectAllCheckbox.checked);
      });
    }

// Filtros de BUSQUEDA
    searchInput.addEventListener('input', loadTracks);
    extensionFilter.addEventListener('change', loadTracks);

// Inicializar
    updateDirectoryLabel();    
    loadTracks();
  </script>
</body>
</html>
